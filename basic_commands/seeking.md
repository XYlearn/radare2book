## 寻址(Seeking)

当前寻址(seek)位置可以使用`s`命令修改。这条命令接受一个数学表达式参数。表达式可以由移位操作，基本数学运算或访问内存操作组成。

    [0x00000000]> s?
    Usage: s[+-] [addr]
    s                 打印当前地址
    s 0x320           寻址到这个地址
    s-                撤销寻址操作
    s+                重做寻址操作
    s*                列举撤销寻址的历史
    s++               向前寻址块大小字节数
    s--               向后寻址块大小字节数
    s+ 512            向前寻址512字节
    s- 512            向后寻址512字节
    sg/sG             寻址到文件头和节头(sg)或文件尾和节尾(sG)
    s.hexoff          Seek honoring a base from core->offset(译者注：没懂)
    sa [[+-]a] [asz]  寻址到a与asz对其后的地址
    sn/sp             寻址到下一个/前一个 scr.nkey
    s/ DATA           搜索下一次出现DATA的位置
    s/x 9091          搜索下一个出现 \x90\x91的位置
    sb                寻址到与块起始位置对其的位置
    so [num]          寻址到往下数第N个opcode
    sf                寻址到下一个函数(f->addr+f->size)
    sC str            寻址到符合给定字符串的注释处
    sr pc             寻址到寄存器

    > 3s++        ; 三次块寻址
    > s 10+0x80   ; 寻址到0x80+10

如果你想查看一个数学表达式的结果，你可以使用`?`指令执行它。只要将表达式作为参数传入即可。结果会以十六进制，十进制，八进制或二进制格式输出。

    > ? 0x100+200
    0x1C8 ; 456d ; 710o ; 1100 1000  

在可是模式下你可以在当前寻址位置按`u`(撤销undo)或`U`(重做redo)返回到寻址历史中前一个或后一个位置。

## 打开文件

让我们使用一个简单的以Linux ELF格式编译的hello_world.c作为测试文件。
我们在编译后使用radare2打开它：

    r2 hello_world

现在我们进入了命令行提示符：

    [0x00400410]>

接下来我们更进一步。

## 寻址到任意位置

寻址指令的地址参数可以使用任何进制，如十六进制/八进制/二进制或十进制。

寻址到地址0x0，可以用`0x0`来替代这条指令

    [0x00400410]> s 0x0
    [0x00000000]>

打印当前地址

    [0x00000000]> s
    0x0
    [0x00000000]>

用另一种方式打印当前位置：`?v $$`。

向前移动N个位置，空格是可选的：

    [0x00000000]> s+ 128
    [0x00000080]>

撤销前两次寻址已返回到初始地址

    [0x00000080]> s-
    [0x00000000]> s-
    [0x00400410]>

我们回到了_0x00400410_。

也有一条显示寻址(seek)历史的指令

    [0x00400410]> s*
    f undo_3 @ 0x400410
    f undo_2 @ 0x40041a
    f undo_1 @ 0x400410
    f undo_0 @ 0x400411
    # Current undo/redo position.
    f redo_0 @ 0x4005b4
